{"version":3,"sources":["webpack:///./src/components/SlideShow.vue?2ebf","webpack:///./src/components/SlideShow.vue?020e","webpack:///./src/components/SlideShowItem.vue","webpack:///src/components/SlideShowItem.vue","webpack:///./src/components/SlideShowItem.vue?9615","webpack:///src/components/SlideShow.vue","webpack:///./src/components/SlideShow.vue?9277","webpack:///./src/components/SlideShow.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","ref","staticClass","on","$event","preventDefault","swipe","style","width","_l","vNode","nodeIndex","key","class","selected","selectedIndex","selectItem","index","attrs","_e","vNodes","showButton","_t","disable","previousDisable","previous","nextDisable","next","showDot","dot","active","moveTo","staticRenderFns","name","props","item","Object","functional","component","addClassCenterItem","centerItem","adjacencyItem","classList","add","remove","removeClassCenterItem","moveNextToWhenInfinite","dotIndex","setTimeout","moveTrack","newIndex","oldIndex","movePrevToWhenInfinite","setCenterClass","adjacencyIndex","moveTrackNextWhenInfinite","resolve","accumulatedWidth","slideShowItems","i","length","getBoundingClientRect","$refs","transition","transform","moveTrackPrevWhenInfinite","components","type","Boolean","default","step","Number","infinite","transitionSpeed","autoplay","autoplayDelay","swipeable","activeIndex","data","dots","playTimer","throttle","dragPosition","startXPos","endXPos","methods","changeIndex","nested","expression","throttling","clientX","changedTouches","subtractedValue","minDragDistance","activeItem","identifier","moved","setDisable","trackRect","sliderRect","left","right","indexOf","createDots","$forceUpdate","$nextTick","sliderRectRight","trackRectRight","foundIndex","changeDots","reversedIndex","Promise","adjustTrackSize","initTrackStyle","automaticPlay","document","hidden","mounted","$scopedSlots","watch","handler","newValue","oldValue","clearTimeout","$emit"],"mappings":"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","file":"js/chunk-e6c88f08.c01059dd.js","sourcesContent":["import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SlideShow.vue?vue&type=style&index=0&id=d108a0ce&scoped=true&lang=css&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SlideShow.vue?vue&type=style&index=0&id=d108a0ce&scoped=true&lang=css&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:\"slideShow\",staticClass:\"slideShow\",on:{\"mousedown\":function($event){$event.preventDefault();return _vm.swipe($event)},\"mouseup\":function($event){$event.preventDefault();return _vm.swipe($event)},\"touchstart\":function($event){$event.preventDefault();return _vm.swipe($event)},\"touchend\":function($event){$event.preventDefault();return _vm.swipe($event)}}},[_c('div',{ref:\"slideShow-wrap\",staticClass:\"slideShow-wrap\",style:({width: 100 + '%'})},[_c('div',{ref:\"slideShow-track\",staticClass:\"slideShow-track\"},[(_vm.vNodes)?_vm._l((_vm.vNodes),function(vNode,nodeIndex){return _c('div',{key:nodeIndex,staticClass:\"slideShow-item-wrap\",class:{selected: nodeIndex === _vm.selectedIndex},on:{\"click\":function($event){return _vm.selectItem(nodeIndex)}}},[_c('SlideShowItem',{key:_vm.index,attrs:{\"item\":vNode}})],1)}):_vm._e()],2)]),(_vm.vNodes && _vm.showButton)?[_vm._t(\"prevButton\",[_c('div',{staticClass:\"slideShow-previous slideShow-button\",class:{disable: _vm.previousDisable},on:{\"click\":_vm.previous}})]),_vm._t(\"nextButton\",[_c('div',{staticClass:\"slideShow-next slideShow-button\",class:{disable: _vm.nextDisable},on:{\"click\":_vm.next}})])]:_vm._e(),(_vm.showDot && !_vm.nextDisable)?_c('div',{staticClass:\"slideShow-dot-wrap\"},_vm._l((_vm.dots),function(dot,index){return _c('div',{key:index,staticClass:\"slideShow-dot\",class:{active : dot},on:{\"click\":function($event){return _vm.moveTo(index)}}})}),0):_vm._e()],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render, staticRenderFns\nimport script from \"./SlideShowItem.vue?vue&type=script&lang=js&\"\nexport * from \"./SlideShowItem.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"fe23669c\",\n  null\n  \n)\n\nexport default component.exports","<script>\r\nexport default {\r\n  name: \"SlideShowItem\",\r\n  props: {\r\n    item: Object\r\n  },\r\n  functional: true,\r\n  render: (createElement, context) => createElement(\"div\", context.props.item.data, context.props.item.children)\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n\r\n</style>","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SlideShowItem.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SlideShowItem.vue?vue&type=script&lang=js&\"","<template>\r\n  <div ref=\"slideShow\" class=\"slideShow\"\r\n       @mousedown.prevent=\"swipe\"\r\n       @mouseup.prevent=\"swipe\"\r\n       @touchstart.prevent=\"swipe\"\r\n       @touchend.prevent=\"swipe\">\r\n    <div class=\"slideShow-wrap\" ref=\"slideShow-wrap\" :style=\"{width: 100 + '%'}\">\r\n      <div class=\"slideShow-track\" ref=\"slideShow-track\">\r\n        <template v-if=\"vNodes\">\r\n          <div class=\"slideShow-item-wrap\"\r\n               v-for=\"(vNode, nodeIndex) in vNodes\"\r\n               :key=\"nodeIndex\"\r\n               :class=\"{selected: nodeIndex === selectedIndex}\"\r\n               @click=\"selectItem(nodeIndex)\">\r\n            <SlideShowItem :item=\"vNode\" :key=\"index\"/>\r\n          </div>\r\n        </template>\r\n      </div>\r\n    </div>\r\n    <template v-if=\"vNodes && showButton\">\r\n      <slot name=\"prevButton\">\r\n        <div class=\"slideShow-previous slideShow-button\"\r\n             :class=\"{disable: previousDisable}\"\r\n             @click=\"previous\"></div>\r\n      </slot>\r\n      <slot name=\"nextButton\">\r\n        <div class=\"slideShow-next slideShow-button\"\r\n             :class=\"{disable: nextDisable}\"\r\n             @click=\"next\"></div>\r\n      </slot>\r\n    </template>\r\n    <div class=\"slideShow-dot-wrap\" v-if=\"showDot && !nextDisable\">\r\n      <div class=\"slideShow-dot\"\r\n           :class=\"{active : dot}\"\r\n           v-for=\"(dot, index) in dots\"\r\n           :key=\"index\"\r\n           @click=\"moveTo(index)\">\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n/**\r\n *  @module pc/common/ui/carousel\r\n *\r\n *  @desc\r\n *  슬라이더 아이템의 순서 변경을 위해, slot을 받아 vNodes(type: Array)로 변환 후,\r\n *  CarouselItem에 vNode(type: Object)를 props로 전달 후 렌더링한다.\r\n *\r\n */\r\nimport SlideShowItem from \"./SlideShowItem.vue\"\r\n\r\n/**\r\n *  @param {Object} centerItem\r\n *  @param {Object} adjacencyItem\r\n *  @desc\r\n *  centerItem에 .slideShow-active 부여하고,<br/>\r\n *  인접한 item에 .slideShow-active 제거한다.\r\n */\r\nfunction addClassCenterItem(centerItem, adjacencyItem) {\r\n  centerItem.classList.add(\"slideShow-active\")\r\n  adjacencyItem && adjacencyItem.classList.remove(\"slideShow-active\")\r\n}\r\n\r\n/**\r\n *  @param {Object} centerItem\r\n *  @param {Object} adjacencyItem\r\n *  @desc\r\n *  centerItem에 .slideShow-active 제거하고,<br/>\r\n *  인접한 item에 .slideShow-active 부여한다.\r\n */\r\nfunction removeClassCenterItem(centerItem, adjacencyItem) {\r\n  centerItem.classList.remove(\"slideShow-active\")\r\n  adjacencyItem && adjacencyItem.classList.add(\"slideShow-active\")\r\n}\r\n\r\n/**\r\n *  @param {Number} dotIndex\r\n *  @desc\r\n *  dotIndex에 맞춰 다음으로 이동한다.<br/>\r\n *  vNodes의 처음부터 해당하는 dotIndex 만큼 복사 후, slideShowItems의 뒤에 붙이고,<br/>\r\n *  adjustTrackSize(), setCenterClass()를 실행한다.<br/>\r\n *  moveTrack가 끝난 후, 처음부터 해당하는  dotIndex 만큼 삭제 후,<br/>\r\n *  adjustTrackSize(), setCenterClass()를 실행한다.\r\n */\r\nfunction moveNextToWhenInfinite(dotIndex) {\r\n  const index = this.changeIndex(this.step * (dotIndex - this.dots.indexOf(true)), true)\r\n\r\n  const cloneNodes = this.vNodes.slice()\r\n  const moveElement = cloneNodes.splice(0, this.step * (dotIndex - this.dots.indexOf(true)))\r\n  this.vNodes = [...this.vNodes, ...moveElement]\r\n\r\n  const adjacencyIndex = this.step * (dotIndex - this.dots.indexOf(true))\r\n\r\n  setTimeout(() => {\r\n    this.slideShowItems = Array.from(this.$el.getElementsByClassName(\"slideShow-item-wrap\"))\r\n    this.adjustTrackSize()\r\n    this.setCenterClass(\"next\", false, adjacencyIndex)\r\n  })\r\n  this.moveTrack(index.newIndex, index.oldIndex)\r\n      .then(() => {\r\n        this.vNodes = [...cloneNodes, ...moveElement]\r\n        this.setCenterClass(\"next\", true, adjacencyIndex)\r\n        setTimeout(() => {\r\n          this.slideShowItems = Array.from(this.$el.getElementsByClassName(\"slideShow-item-wrap\"))\r\n          this.adjustTrackSize()\r\n        })\r\n      })\r\n}\r\n\r\n/**\r\n *  @param {Number} dotIndex\r\n *  @desc\r\n *  dotIndex에 맞춰 이전으로 이동한다.<br/>\r\n *  vNodes의 마지막부터 해당하는 dotIndex 만큼 복사 후, slideShowItems 앞에 붙이고,<br/>\r\n *  adjustTrackSize(), setCenterClass()를 실행한다.<br/>\r\n *  moveTrack가 끝난 후, 마지막부터 해당하는  dotIndex 만큼 삭제 후,<br/>\r\n *  adjustTrackSize(), setCenterClass()를 실행한다.\r\n */\r\nfunction movePrevToWhenInfinite(dotIndex) {\r\n  const index = this.changeIndex(-this.step * (this.dots.indexOf(true) - dotIndex), true)\r\n\r\n  const cloneNodes = this.vNodes.slice()\r\n  const moveElement = cloneNodes.splice((cloneNodes.length - this.step * (this.dots.indexOf(true) - dotIndex)), cloneNodes.length - 1)\r\n  this.vNodes = [...moveElement, ...this.vNodes]\r\n\r\n  const adjacencyIndex = this.step * (this.dots.indexOf(true) - dotIndex)\r\n  this.setCenterClass(\"previous\", false, adjacencyIndex)\r\n\r\n  setTimeout(() => {\r\n    this.slideShowItems = Array.from(this.$el.getElementsByClassName(\"slideShow-item-wrap\"))\r\n    this.adjustTrackSize()\r\n    this.setCenterClass(\"previous\", true, adjacencyIndex)\r\n  })\r\n  this.moveTrack(index.newIndex, index.oldIndex)\r\n      .then(() => {\r\n        this.vNodes = [...moveElement, ...cloneNodes]\r\n        setTimeout(() => {\r\n          this.slideShowItems = Array.from(this.$el.getElementsByClassName(\"slideShow-item-wrap\"))\r\n          this.adjustTrackSize()\r\n        })\r\n      })\r\n}\r\n\r\n/**\r\n *  @param {Number} newIndex\r\n *  @param {Number} oldIndex\r\n *  @param {function} resolve\r\n *  @desc\r\n *  infinite=true일 때, 해당하는 index만큼 track를 앞으로 이동한다.\r\n */\r\nfunction moveTrackNextWhenInfinite(newIndex, oldIndex, resolve) {\r\n  let accumulatedWidth = 0\r\n  if (newIndex <= 0) {\r\n    for (let i = Math.abs(newIndex); i < Math.abs(oldIndex); i++)\r\n      accumulatedWidth += this.slideShowItems[i % this.slideShowItems.length].getBoundingClientRect().width\r\n    if (newIndex < 0) accumulatedWidth = -accumulatedWidth\r\n  } else\r\n    for (let i = Math.abs(oldIndex); i < Math.abs(newIndex); i++)\r\n      accumulatedWidth += this.slideShowItems[i % this.slideShowItems.length].getBoundingClientRect().width\r\n\r\n  if (this.index < 0) accumulatedWidth = -accumulatedWidth\r\n  this.$refs[\"slideShow-track\"].style.transition = `transform ${this.transitionSpeed}ms ease`\r\n  this.$refs[\"slideShow-track\"].style.transform = `translateX(${-accumulatedWidth}px)`\r\n  setTimeout(() => {\r\n    this.$refs[\"slideShow-track\"].style.transition = `none`\r\n    this.$refs[\"slideShow-track\"].style.transform = `translateX(${0}px)`\r\n    resolve()\r\n  }, this.transitionSpeed)\r\n}\r\n\r\n/**\r\n *  @param {Number} newIndex\r\n *  @param {Number} oldIndex\r\n *  @param {function} resolve\r\n *  @desc\r\n *  infinite=true일 때, 해당하는 index만큼 track를 뒤로 이동한다.\r\n */\r\nfunction moveTrackPrevWhenInfinite(newIndex, oldIndex, resolve) {\r\n  let accumulatedWidth = 0\r\n  const setAccumulatedWidth = (indexBetweenOldAndNew) => {\r\n    accumulatedWidth += this.slideShowItems[this.slideShowItems.length - (indexBetweenOldAndNew % this.slideShowItems.length) - 1].getBoundingClientRect().width\r\n  }\r\n  if (newIndex < 0)\r\n    for (let i = Math.abs(oldIndex); i < Math.abs(newIndex); i++)\r\n      setAccumulatedWidth(i)\r\n  else\r\n    for (let i = Math.abs(newIndex); i < Math.abs(oldIndex); i++)\r\n      setAccumulatedWidth(i)\r\n\r\n  this.$refs[\"slideShow-track\"].style.transition = `none`\r\n  this.$refs[\"slideShow-track\"].style.transform = `translateX(${-accumulatedWidth}px)`\r\n  setTimeout(() => {\r\n    this.$refs[\"slideShow-track\"].style.transition = `transform ${this.transitionSpeed}ms ease`\r\n    this.$refs[\"slideShow-track\"].style.transform = `translateX(${0}px)`\r\n  })\r\n  setTimeout(() => {\r\n    resolve()\r\n  }, this.transitionSpeed)\r\n}\r\n\r\nexport default {\r\n  name: \"SlideShow\",\r\n  components: {SlideShowItem},\r\n  /**\r\n   *  @vue-prop {Boolean} [showDot=false] - Dot 표시여부를 정한다.\r\n   *  @vue-prop {Number} [step=1] - 한번에 움직일때, 몇칸씩 움직일지 결정한다.\r\n   *  @vue-prop {Boolean} [infinite=false] - 무한슬라이딩 여부를 정한다.\r\n   *  @vue-prop {Number} [transitionSpeed=500] - 움직일때 일어나는 트랜지션의 속도를 결정한다.\r\n   *  @vue-prop {Boolean} [showButton=false] - 버튼 표시여부를 정한다.\r\n   *  @vue-prop {Boolean} [autoplay=false] - 자동재생여부를 결정한다.\r\n   *  @vue-prop {Number} [autoplayDelay=5000] - 자동재생시 딜레이를 정한다. (단위: ms)\r\n   *  @vue-prop {Boolean} [swipeable=false] - 스와이프/드래그로 이동을 할지 결정한다.\r\n   *  @vue-prop {Number} [activeIndex=0] - n번째 아이템에 .slideShow-active를 부여한다.\r\n   */\r\n  props: {\r\n    showDot: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    step: {\r\n      type: Number,\r\n      default: 1\r\n    },\r\n    infinite: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    transitionSpeed: {\r\n      type: Number,\r\n      default: 500\r\n    },\r\n    showButton: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    autoplay: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    autoplayDelay: {\r\n      type: Number,\r\n      default: 5000\r\n    },\r\n    swipeable: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    activeIndex: {\r\n      type: Number,\r\n      default: 1\r\n    }\r\n  },\r\n  /**\r\n   *  @vue-data {Number} index - 현재 위치\r\n   *  @vue-data {Number} selectedIndex - 선택된 위치\r\n   *  @vue-data {Boolean} previousDisable - 뒤로 이동할 수 있을지 여부 판단한다.\r\n   *  @vue-data {Boolean} nextDisable - 뒤로 이동할 수 있을지 여부 판단한다.\r\n   *  @vue-data {Array} slideShowItems - track 내부의 dom-nodes.\r\n   *  @vue-data {Array} dots - dot.\r\n   *  @vue-data {Array} vNodes - track 내부의 v-nodes.\r\n   *  @vue-data {Array} originalVNodeSet - slots 으로 받은 item의 복사되기 전 vnodes.\r\n   *  @vue-data {Object} playTimer - autoPlay에 필요한 타이머.\r\n   *  @vue-data {Boolean} throttle - next/prev/move 중에 delay.\r\n   *  @vue-data {Object} dragPosition - drag/swipe 때 마우스 위치.\r\n   */\r\n  data() {\r\n    return {\r\n      index: 0,\r\n      selectedIndex: 0,\r\n      previousDisable: false,\r\n      nextDisable: false,\r\n      slideShowItems: null,\r\n      dots: [],\r\n      vNodes: null,\r\n      playTimer: null,\r\n      throttle: false,\r\n      dragPosition: {\r\n        startXPos: null,\r\n        endXPos: null\r\n      }\r\n    }\r\n  },\r\n  methods: {\r\n    /**\r\n     *  @param {Number} nodeIndex\r\n     *  @desc\r\n     *  selectedIndex를 바꾼다.\r\n     */\r\n    selectItem(nodeIndex) {\r\n      this.selectedIndex = nodeIndex\r\n    },\r\n    /**\r\n     *  @param {Number} expression\r\n     *  @param {Boolean} nested\r\n     *  @return {{oldIndex: number, newIndex: number}}\r\n     *  @desc\r\n     *  index를 바꾸고, 바뀌기 전의 index, 바뀐 후의 index를 리턴한다.\r\n     */\r\n    changeIndex(expression, nested) {\r\n      const oldIndex = this.index\r\n      if (nested) this.index += expression\r\n      else this.index = expression\r\n      const newIndex = this.index\r\n\r\n      return {newIndex, oldIndex}\r\n    },\r\n    /**\r\n     *  @desc\r\n     *  CSS 에러를 대비하여 next(),prev(),moveTo 메서드 호출시 간격을 준다.\r\n     */\r\n    throttling() {\r\n      this.throttle = true\r\n      setTimeout(() => {\r\n        this.throttle = false\r\n      }, this.transitionSpeed)\r\n    },\r\n    /**\r\n     *  @param {Object} $event\r\n     *  @desc\r\n     *  mousedown/mouseup, touchstart/touchend 시 값을 저장하고,<br/>\r\n     *  비교하여 next()/previous() 한다.\r\n     */\r\n    swipe($event) {\r\n      if (!this.swipeable) return\r\n      const minDragDistance = 100\r\n      if ($event.type === \"mousedown\" || $event.type === \"touchstart\") {\r\n        //이벤트 시작 지점\r\n        this.dragPosition.startXPos = $event.clientX || $event.changedTouches[0].clientX\r\n      }\r\n      if ($event.type === \"mouseup\" || $event.type === \"touchend\") {\r\n        //이벤트 종료 지점\r\n        this.dragPosition.endXPos = $event.clientX || $event.changedTouches[0].clientX\r\n        const subtractedValue = this.dragPosition.startXPos - this.dragPosition.endXPos\r\n\r\n        if (subtractedValue > minDragDistance) this.next()\r\n        else if (subtractedValue < -minDragDistance) this.previous()\r\n        //동작이 끝나면 담긴 값은 null로 초기화\r\n        this.dragPosition.endXPos = null\r\n        this.dragPosition.startXPos = null\r\n      }\r\n    },\r\n    /**\r\n     *  @param {String} identifier\r\n     *  @param {Boolean} moved\r\n     *  @param {Number} adjacencyIndex\r\n     *  @desc\r\n     *  active-index의 값에 따라 해당 item에 .slideShow-active를 부여한다.\r\n     */\r\n    setCenterClass(identifier, moved, adjacencyIndex) {\r\n      if (!this.infinite) return\r\n      const activeIndex = this.activeIndex - 1\r\n      const activeItem = this.slideShowItems[activeIndex]\r\n      if (!activeItem) return\r\n      if (!identifier) activeItem.classList.add(\"slideShow-active\")\r\n\r\n      if (moved) {\r\n        if (adjacencyIndex)\r\n          addClassCenterItem(activeItem, this.slideShowItems[activeIndex + adjacencyIndex])\r\n        else {\r\n          if (identifier === \"next\")\r\n            addClassCenterItem(activeItem, this.slideShowItems[activeIndex + this.step])\r\n          if (identifier === \"previous\")\r\n            removeClassCenterItem(activeItem, this.slideShowItems[activeIndex + this.step])\r\n        }\r\n      } else {\r\n        if (adjacencyIndex)\r\n          removeClassCenterItem(activeItem, this.slideShowItems[activeIndex + adjacencyIndex])\r\n        else {\r\n          if (identifier === \"next\")\r\n            removeClassCenterItem(activeItem, this.slideShowItems[activeIndex + this.step])\r\n          if (identifier === \"previous\")\r\n            addClassCenterItem(activeItem, this.slideShowItems[activeIndex + this.step])\r\n        }\r\n      }\r\n    },\r\n    /**\r\n     *  @param {Number} newIndex\r\n     *  @param {Number} oldIndex\r\n     *  @desc\r\n     *  mount,next(),previous(),moveTo() 때 nextDisable, previousDisable이 true인지 false인지 판단한다.<br/>\r\n     *  infinite=true일 때, 작동하지 않는다.\r\n     */\r\n    setDisable(newIndex, oldIndex) {\r\n      const sliderRect = this.$refs[\"slideShow-wrap\"].getBoundingClientRect()\r\n      const trackRect = this.$refs[\"slideShow-track\"].getBoundingClientRect()\r\n      if (this.infinite) {\r\n        if (trackRect.width <= sliderRect.width) {\r\n          this.nextDisable = true\r\n          this.previousDisable = true\r\n        }\r\n      }else {\r\n        this.nextDisable = this.index > this.slideShowItems.length - 1\r\n        this.previousDisable = this.index === 0\r\n        //마운트할때\r\n        if (!(oldIndex) && sliderRect.x + this.$refs.slideShow.getBoundingClientRect().width >= trackRect.right)\r\n          return this.nextDisable = true\r\n        //next() 할때\r\n        if (newIndex > oldIndex) {\r\n          let accumulatedWidth = 0\r\n          for (let i = newIndex; i < this.slideShowItems.length; i++)\r\n            accumulatedWidth += this.slideShowItems[i].getBoundingClientRect().width\r\n\r\n          this.nextDisable = sliderRect.left + accumulatedWidth <= sliderRect.right\r\n        }\r\n      }\r\n\r\n    },\r\n    /**\r\n     *  @desc\r\n     *  step 만큼 다음으로 이동한다.\r\n     */\r\n    next() {\r\n      if (this.throttle) return\r\n      if (this.nextDisable) return\r\n      const index = this.changeIndex(this.step, true)\r\n      setTimeout(() => {\r\n        this.setCenterClass(\"next\", false)\r\n      })\r\n\r\n      this.moveTrack(index.newIndex, index.oldIndex)\r\n          .then(() => {\r\n            if (this.infinite) {\r\n              const moveElement = this.vNodes.splice(0, this.step)\r\n              this.vNodes = [...this.vNodes, ...moveElement]\r\n              this.setCenterClass(\"next\", true)\r\n            }\r\n          })\r\n\r\n      this.throttling()\r\n    },\r\n    /**\r\n     *  @desc\r\n     *  step 만큼 뒤로 이동한다.\r\n     */\r\n    previous() {\r\n      if (this.throttle) return\r\n      if (this.previousDisable) return\r\n      const index = this.changeIndex(-this.step, true)\r\n      setTimeout(() => {\r\n        this.setCenterClass(\"previous\", false)\r\n      })\r\n      this.setCenterClass(\"previous\", true)\r\n\r\n      if (this.infinite) {\r\n        const moveElement = this.vNodes.splice(this.vNodes.length - this.step, this.vNodes.length - 1)\r\n        this.vNodes = [...moveElement, ...this.vNodes]\r\n      }\r\n      this.moveTrack(index.newIndex, index.oldIndex)\r\n      this.throttling()\r\n    },\r\n    /**\r\n     *  @param {Number} dotIndex\r\n     *  @desc\r\n     *  dotIndex * step 만큼 이동한다.<br/>\r\n     *  infinite = true일때, dotIndex와 현재 true인 dot의 차이만큼 앞/뒤로 이동한다.\r\n     */\r\n    moveTo(dotIndex) {\r\n      if (this.throttle) return\r\n      if (this.vNodes.length <= 1) return\r\n      if (!this.infinite) {\r\n        const index = this.changeIndex(dotIndex * this.step, false)\r\n        this.moveTrack(index.newIndex, index.oldIndex)\r\n        return\r\n      }\r\n      if (dotIndex > this.dots.indexOf(true))\r\n        moveNextToWhenInfinite.bind(this)(dotIndex)\r\n      else if (dotIndex < this.dots.indexOf(true))\r\n        movePrevToWhenInfinite.bind(this)(dotIndex)\r\n\r\n      this.throttling()\r\n    },\r\n    /**\r\n     *  @desc\r\n     *  페이지 수의 맞게 dot를 표시한다.\r\n     */\r\n    createDots() {\r\n      if (!this.showDot) return\r\n      if (this.infinite) {\r\n        for (let i = 0; i < this.slideShowItems.length / this.step; i++)\r\n          this.dots[i] = false\r\n        this.dots[0] = true\r\n        this.$forceUpdate()\r\n        return\r\n      }\r\n\r\n      this.$nextTick(() => {\r\n        let sliderRectRight = this.$refs[\"slideShow-wrap\"].getBoundingClientRect().right\r\n        let trackRectRight = this.$refs[\"slideShow-track\"].getBoundingClientRect().right\r\n        if (sliderRectRight < trackRectRight) {\r\n          let foundIndex = 0\r\n          for (let i = 0; i < this.slideShowItems.length; i++) {\r\n            trackRectRight -= this.slideShowItems[i].getBoundingClientRect().width * this.step\r\n            if (trackRectRight <= sliderRectRight) {\r\n              foundIndex = i\r\n              break\r\n            }\r\n          }\r\n          for (let i = 0; i <= foundIndex + 1; i++) {\r\n            this.dots[i] = false\r\n          }\r\n        }\r\n        this.dots[0] = true\r\n        this.$forceUpdate()\r\n      })\r\n    },\r\n    /**\r\n     * @desc\r\n     * 현재 페이지를 표시한다.\r\n     */\r\n    changeDots() {\r\n      if (!this.showDot) return\r\n      if (this.vNodes.length < 1) return\r\n      for (let i = 0; i < this.dots.length; i++) {\r\n        this.dots[i] = false\r\n      }\r\n      if (!this.infinite) {\r\n        this.dots[this.index / this.step] = true\r\n        return\r\n      }\r\n      let cloneIndex = Math.abs(this.index)\r\n      if (this.index >= 0) {\r\n        this.dots[(cloneIndex / this.step) % Math.ceil((this.slideShowItems.length + 1 - this.step) / this.step)] = true\r\n        return\r\n      }\r\n      let reversedIndex = this.dots.length - (cloneIndex / this.step) % Math.ceil(this.slideShowItems.length / this.step)\r\n      if (this.dots.length === reversedIndex) reversedIndex = 0\r\n      this.dots[reversedIndex] = true\r\n    },\r\n    /**\r\n     * @param {Number} newIndex\r\n     * @param {Number} oldIndex\r\n     * @desc\r\n     * 현재 index에 맞게 track를 움직인다.\r\n     */\r\n    moveTrack(newIndex, oldIndex) {\r\n      if (this.vNodes.length < 1) return\r\n      return new Promise(resolve => {\r\n        if (this.infinite) {\r\n          if (newIndex > oldIndex)\r\n            moveTrackNextWhenInfinite.bind(this)(newIndex, oldIndex, resolve)\r\n          else\r\n            moveTrackPrevWhenInfinite.bind(this)(newIndex, oldIndex, resolve)\r\n        } else {\r\n          let accumulatedWidth = 0\r\n          for (let i = 0; i < this.index; i++) {\r\n            accumulatedWidth += this.slideShowItems[i].getBoundingClientRect().width\r\n          }\r\n          this.$refs[\"slideShow-track\"].style.transform = `translateX(${-accumulatedWidth}px)`\r\n          setTimeout(() => {\r\n            resolve()\r\n          })\r\n        }\r\n      })\r\n    },\r\n    /**\r\n     *  @desc\r\n     *  mount시 track 사이즈를 슬라이더아이템 갯수에 맞게 조정한다.\r\n     */\r\n    adjustTrackSize() {\r\n      return new Promise(resolve => {\r\n        setTimeout(() => {\r\n          this.$refs[\"slideShow-track\"].style.height = this.slideShowItems[0].clientHeight + \"px\"\r\n          this.$refs[\"slideShow-track\"].style.width = this.slideShowItems\r\n              .map(item => {\r\n                let sideMargin = getComputedStyle(item).getPropertyValue(\"margin\").split(\" \")[1] || 0\r\n                return item.getBoundingClientRect().width + (parseInt(sideMargin) * 2)\r\n              })\r\n              .reduce((acc, current) => acc + current) + \"px\"\r\n          resolve()\r\n        })\r\n      })\r\n    },\r\n    /**\r\n     *  @desc\r\n     *  track의 transition을 조정한다.\r\n     */\r\n    initTrackStyle() {\r\n      this.$refs[\"slideShow-track\"].style.transition = `transform ${this.transitionSpeed}ms ease`\r\n    },\r\n    /**\r\n     *  @desc\r\n     *  autoplayDelay의 간격으로 자동으로 next()한다.\r\n     */\r\n    automaticPlay() {\r\n      if (document.hidden) return\r\n      return setTimeout(() => {\r\n        this.next()\r\n      }, this.autoplayDelay)\r\n    }\r\n  },\r\n  mounted() {\r\n    this.vNodes = this.$scopedSlots.item()\r\n    if (this.vNodes.length < 1) return\r\n    this.$nextTick(() => {\r\n      this.slideShowItems = Array.from(this.$el.getElementsByClassName(\"slideShow-item-wrap\"))\r\n      this.setCenterClass()\r\n      this.adjustTrackSize()\r\n          .then(() => {\r\n            this.initTrackStyle()\r\n            this.createDots()\r\n            this.setDisable()\r\n            if (this.autoplay) this.playTimer = this.automaticPlay()\r\n          })\r\n    })\r\n  },\r\n  watch: {\r\n    index: {\r\n      handler(newValue, oldValue) {\r\n        this.setDisable(newValue, oldValue)\r\n        this.changeDots()\r\n        if (this.autoplay) {\r\n          clearTimeout(this.playTimer)\r\n          this.playTimer = this.automaticPlay()\r\n        }\r\n        this.$emit(\"getIndex\", this.index)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n</script>\r\n\r\n<style scoped>\r\n* {\r\n  box-sizing: border-box;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\n.slideShow {\r\n  position: relative;\r\n}\r\n\r\n.slideShow-wrap {\r\n  overflow: hidden;\r\n}\r\n\r\n.slideShow-button {\r\n  color: white;\r\n  cursor: pointer;\r\n  border: none;\r\n  padding: 10px;\r\n  position: absolute;\r\n  top: 50%;\r\n  z-index: 999;\r\n}\r\n\r\n.slideShow-item-wrap {\r\n  display: inline-block;\r\n}\r\n\r\n.slideShow-previous {\r\n  left: 0;\r\n  transform: translate(-100%, -50%);\r\n  background: url(\"../../resources/images/common/set_arr_slide_small.png\") 8px 0 no-repeat;\r\n}\r\n\r\n.slideShow-previous.disable {\r\n  background: url(\"../../resources/images/common/set_arr_slide_small.png\") -12px 0 no-repeat;\r\n}\r\n\r\n.slideShow-next {\r\n  right: 0;\r\n  transform: translate(100%, -50%);\r\n  background: url(\"../../resources/images/common/set_arr_slide_small.png\") 12px -16px no-repeat;\r\n}\r\n\r\n.slideShow-next.disable {\r\n  background: url(\"../../resources/images/common/set_arr_slide_small.png\") -8px -16px no-repeat;\r\n}\r\n\r\n.slideShow-dot-wrap {\r\n  position: absolute;\r\n  bottom: 0;\r\n  left: 50%;\r\n  transform: translate(-50%, 150%);\r\n}\r\n\r\n.slideShow-dot {\r\n  display: inline-block;\r\n  width: 10px;\r\n  height: 10px;\r\n  border-radius: 50%;\r\n  margin: 0 4px;\r\n  background: black;\r\n  opacity: 0.3;\r\n  cursor: pointer;\r\n  z-index: 99;\r\n}\r\n\r\n.slideShow-dot.active {\r\n  opacity: 0.75;\r\n}\r\n\r\n.slideShow-track {\r\n  overflow: hidden;\r\n}\r\n</style>","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SlideShow.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SlideShow.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./SlideShow.vue?vue&type=template&id=d108a0ce&scoped=true&\"\nimport script from \"./SlideShow.vue?vue&type=script&lang=js&\"\nexport * from \"./SlideShow.vue?vue&type=script&lang=js&\"\nimport style0 from \"./SlideShow.vue?vue&type=style&index=0&id=d108a0ce&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"d108a0ce\",\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}